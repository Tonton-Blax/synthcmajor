namespace Synthe {


graph SynthMain  [[ main ]]
{
    input GateToNote.boolIn  [[ name: "boolIn", init: false, type: "bool" ]];
    input freqHandler.osc1FreqIn [[ name: "Osc1FreqIn",  min: 40, max: 40000, init:  100, type: "float",  step: 1 ]];
    input freqHandler.osc2FreqIn [[ name: "Osc2FreqIn",  min: 40, max: 40000, init:  100, type: "float",  step: 1 ]];

    output stream float audioOut;

    node
    {
        voices = Voice[8];
        freqHandler = FreqHandler;
        voiceAllocator = std::voices::VoiceAllocator(8);
    }


    connection
    {
        GateToNote.noteOut -> std::midi::NoteToMIDI -> std::midi::MPEConverter -> voiceAllocator;
        voiceAllocator.voiceEventOut -> voices.noteOn, voices.noteOff, voices.pitchBend;
        freqHandler.osc1FreqOut -> voices.osc1FreqIn;
        freqHandler.osc2FreqOut -> voices.osc2FreqIn;
        voices -> audioOut;
    }
}

graph Voice
{
    input event
    {
        std::notes::NoteOn noteOn;
        std::notes::NoteOff noteOff;
        std::notes::PitchBend pitchBend;
        float osc1FreqIn;
        float osc2FreqIn;
    }

    output stream float audioOut;

    node
    {
        envelope = std::envelopes::FixedASR (0.0f, 0.3f);
        attenuator = std::levels::DynamicGain (float);
        ntf = NoteToFrequency;
        osc1 = std::oscillators::Sine (float, 440);
        osc2 = std::oscillators::PolyblepOscillator (float, std::oscillators::Shape::sawtoothUp, 440);
    }

    connection
    {
        noteOn, noteOff -> ntf;
        osc1FreqIn -> osc1.frequencyIn;
        osc2FreqIn -> osc2.frequencyIn;
        noteOn, noteOff -> envelope -> attenuator.gain;   
        osc1.out + osc2.out -> attenuator.in;
        attenuator -> audioOut;
    }
}

graph FreqHandler
{
    input event {
        float osc1FreqIn;
        float osc2FreqIn;
    }

    output event {
        float osc1FreqOut;
        float osc2FreqOut;
    }

    const float freqFactor = 1.5f;

    event osc1FreqIn (float newFreq)  {
        osc1FreqOut <- newFreq * freqFactor / 100.0f;
    }
    event osc2FreqIn (float newFreq)  {
        osc2FreqOut <- newFreq * freqFactor / 100.0f;
    }
}

graph GateToNote
{
    input event bool boolIn;
    output event (std::notes::NoteOn,
                  std::notes::NoteOff) noteOut;
    // This simple struct holds a note + duration for our melody


    void play()
    {
        std::notes::NoteOn noteOn;
        noteOn.pitch = 60.0f;
        noteOn.velocity = 1.0f;
        noteOut <- noteOn;
    }

    void stop()
    {
        std::notes::NoteOff noteOff;
        noteOff.pitch = 60.0f;
        noteOff.velocity = 1.0f;
        noteOut <- noteOff;
    }

    event boolIn (bool g) {
        if (g) {
            play();
        }
        else
            stop();        
    }
}

graph NoteToFrequency {
    input event (std::notes::NoteOn,std::notes::NoteOff) eventIn;
    output event float frequencyOut;

    event eventIn (std::notes::NoteOn note) {
        //frequencyOut <- std::notes::NoteToFrequency(note.pitch);
        frequencyOut <- 380.0f;
    }
    event eventIn (std::notes::NoteOff note) {
        frequencyOut <- 0.0f;
    }
}
}